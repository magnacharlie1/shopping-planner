<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Shopping Planner</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&family=Inter:wght@400;500;600&display=swap"
    rel="stylesheet"
  >
  <script src="https://cdn.auth0.com/js/auth0-spa-js/2.5/auth0-spa-js.production.js"></script>
  <style>
    :root {
      --bg: #f5f7fb;
      --card: #ffffff;
      --primary: #2563eb;
      --primary-strong: #1d4ed8;
      --muted: #4b5563;
      --border: #e4e4e7;
      --shadow: 0 18px 50px rgba(15, 23, 42, 0.12);
      --radius: 16px;
    }

    * {
      box-sizing: border-box;
      font-family: "Inter", "Space Grotesk", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at 10% 20%, #e0f2fe 0, #f5f7fb 30%, #f5f7fb 100%);
      color: #0f172a;
      padding: 0.5rem;
    }

    .app {
      background: var(--card);
      padding: 1.75rem;
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      width: 100%;
      max-width: 560px;
      border: 1px solid rgba(226, 232, 240, 0.7);
    }

    h1 {
      margin: 0 0 0.6rem;
      font-size: 1.45rem;
      text-align: center;
      letter-spacing: -0.02em;
    }

    .subtitle {
      text-align: center;
      color: #6b7280;
      margin: 0 0 1.1rem;
      font-size: 0.95rem;
    }

    /* Auth bar at top of card */
    .auth-bar {
      display: flex;
      justify-content: flex-end;
      gap: 0.6rem;
      margin-bottom: 0.9rem;
      font-size: 0.85rem;
      color: var(--muted);
    }

    #user-label {
      align-self: center;
    }

    .auth-bar button {
      padding: 0.35rem 0.7rem;
      font-size: 0.8rem;
      background: #f3f4f6;
      color: #0f172a;
      border-radius: 999px;
      border: none;
      cursor: pointer;
    }

    /* Mode toggle (Shopping / Menu) */
    .mode-toggle {
      display: flex;
      align-items: center;
      gap: 0.35rem;
      margin: 0 0 1rem;
      padding: 0.28rem;
      border-radius: 999px;
      background: #eef2ff;
      border: 1px solid #e0e7ff;
    }

    .mode-btn {
      flex: 1;
      border-radius: 999px;
      border: none;
      background: transparent;
      font-size: 0.88rem;
      padding: 0.32rem 0.7rem;
      cursor: pointer;
      color: #4b5563;
    }

    .mode-btn.active {
      background: linear-gradient(135deg, var(--primary), var(--primary-strong));
      color: #ffffff;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
    }

    .list-switcher {
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem;
      align-items: center;
      margin-bottom: 0.75rem;
    }

    .list-switcher select {
      flex: 1;
      min-width: 0;
      padding: 0.45rem 0.6rem;
      border-radius: 0.75rem;
      border: 1px solid #d4d4d8;
      font-size: 0.93rem;
      background: #fff;
    }

    .list-switcher button {
      padding: 0.35rem 0.65rem;
      border-radius: 0.6rem;
      border: none;
      font-size: 0.8rem;
      cursor: pointer;
      background: #f3f4f6;
      color: #0f172a;
      white-space: nowrap;
    }

    .list-switcher button.primary {
      background: linear-gradient(135deg, #4f46e5, #2563eb);
      color: white;
    }

    .top-form {
      display: flex;
      gap: 0.65rem;
      margin-bottom: 1.1rem;
    }

    input[type="text"] {
      flex: 1;
      padding: 0.55rem 0.7rem;
      border-radius: 0.75rem;
      border: 1px solid #d4d4d8;
      font-size: 1rem;
      background: #fcfcfd;
    }

    button {
      padding: 0.55rem 0.9rem;
      border-radius: 0.75rem;
      border: none;
      font-size: 0.95rem;
      cursor: pointer;
      background: linear-gradient(135deg, var(--primary), var(--primary-strong));
      color: white;
      white-space: nowrap;
      transition: transform 120ms ease, box-shadow 120ms ease;
    }

    button:active {
      transform: translateY(1px);
      box-shadow: inset 0 2px 6px rgba(0, 0, 0, 0.12);
    }

    .lists {
      display: flex;
      flex-direction: column;
      gap: 1.35rem;
    }

    .list-section {
      border-top: 1px solid var(--border);
      padding-top: 0.85rem;
    }

    .list-section:first-of-type {
      border-top: none;
      padding-top: 0;
    }

    .section {
      padding: 0.6rem 0;
      border-bottom: 1px solid #f4f4f5;
    }

    .section:last-child {
      border-bottom: none;
    }

    .section-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      margin-bottom: 0.35rem;
    }

    .section-header h2 {
      margin: 0;
      font-size: 1.05rem;
      letter-spacing: -0.01em;
    }

    .count {
      font-size: 0.85rem;
      color: #6b7280;
    }

    .item-form {
      display: flex;
      gap: 0.45rem;
      margin-bottom: 0.4rem;
    }

    .item-form input[type="text"] {
      font-size: 0.95rem;
      padding: 0.35rem 0.55rem;
    }

    .item-form button {
      font-size: 0.85rem;
      padding: 0.35rem 0.65rem;
    }

    ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .active-list {
      min-height: 0.5rem;
      padding: 0.1rem 0;
    }

    li {
      padding: 0.25rem 0;
      border-bottom: 1px solid #f1f5f9;
    }

    .item-row {
      display: flex;
      align-items: center;
      gap: 0.65rem;
      padding: 0.45rem 0.35rem;
      border-radius: 12px;
      transition: background-color 120ms ease, transform 120ms ease;
    }

    .item-row:hover {
      background: #f8fafc;
    }

    .item-row:active {
      transform: scale(0.995);
    }

    li:last-child {
      border-bottom: none;
    }

    label {
      display: flex;
      align-items: center;
      gap: 0.55rem;
      cursor: pointer;
      font-size: 1rem;
      flex: 1;
    }

    input[type="checkbox"] {
      width: 1.1rem;
      height: 1.1rem;
      cursor: pointer;
      accent-color: var(--primary);
    }

    .item-text {
      flex: 1;
      line-height: 1.4;
    }

    .completed-item .item-text {
      text-decoration: line-through;
      opacity: 0.7;
    }

    .section-tag {
      font-size: 0.78rem;
      padding: 0.08rem 0.4rem;
      border-radius: 999px;
      border: 1px solid #e4e4e7;
      color: #334155;
      background: #f8fafc;
    }

    /* Hide section tag in active lists; only show in Completed */
    .section .section-tag {
      display: none;
    }

    #completed-list .section-tag {
      display: inline-block;
    }

    .empty {
      text-align: center;
      font-size: 0.9rem;
      color: #9ca3af;
      margin-top: 0.35rem;
    }

    .completed-section-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      margin-bottom: 0.3rem;
    }

    .completed-section-header h2 {
      margin: 0;
      font-size: 1.05rem;
      letter-spacing: -0.01em;
    }

    /* Drop hint area for empty sections */
    .drop-area {
      font-size: 0.85rem;
      color: #4f46e5;
      border: 1px dashed #c7d2fe;
      border-radius: 0.75rem;
      padding: 0.5rem 0.65rem;
      margin-bottom: 0.35rem;
      text-align: center;
      background: #f8fafc;
      letter-spacing: -0.01em;
    }

    .drop-area.hidden {
      display: none;
    }

    /* Drag & drop styling */
    .item.dragging {
      opacity: 0.5;
      transform: scale(0.997);
    }

    .active-list.drop-target,
    .drop-area.drop-target {
      background: #eef2ff;
      border-color: #4f46e5;
    }

    /* Blue line showing where the item will be inserted */
    .drop-indicator {
      border-top: 2px solid #3b82f6;
      margin: 0.1rem 0;
      padding: 0;
      height: 0;
      list-style: none;
    }

    /* Menu mode: hide editing + Completed section */
    .app.mode-menu #completed-section {
      display: none;
    }

    .drag-handle {
      width: 34px;
      height: 34px;
      border-radius: 10px;
      border: 1px solid #e5e7eb;
      background: #f8fafc;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      color: #475569;
      cursor: grab;
      touch-action: none;
      transition: background-color 120ms ease, box-shadow 120ms ease;
    }

    .drag-handle:active {
      cursor: grabbing;
      background: #eef2ff;
      box-shadow: inset 0 0 0 1px #c7d2fe;
    }

    .drag-handle svg {
      width: 18px;
      height: 18px;
      color: #1f2937;
      opacity: 0.85;
    }

    .drag-hint {
      display: flex;
      align-items: center;
      gap: 0.35rem;
      color: #64748b;
      font-size: 0.85rem;
      margin: 0 0 0.5rem;
    }

    .drag-hint svg {
      width: 16px;
      height: 16px;
      color: #4f46e5;
    }

    .app.mode-menu #add-section-form {
      display: none;
    }

    .app.mode-menu .item-form {
      display: none;
    }

    .app.mode-menu .drop-area {
      display: none;
    }

    /* ---------- Mobile tweaks ---------- */
    @media (max-width: 640px) {
      body {
        align-items: stretch;
        justify-content: flex-start;
        background: #ffffff;
      }

      .app {
        max-width: 100%;
        width: 100%;
        min-height: 100vh;
        border-radius: 0;
        box-shadow: none;
        padding: 1.2rem 0.9rem 1.6rem;
      }

      h1 {
        font-size: 1.25rem;
        margin-bottom: 0.5rem;
      }

      .auth-bar {
        justify-content: center;
        flex-wrap: wrap;
      }

      .mode-toggle {
        margin-bottom: 0.5rem;
      }

      .list-switcher {
        flex-direction: column;
        align-items: stretch;
      }

      .list-switcher select {
        width: 100%;
      }

      .list-switcher button {
        width: 100%;
        justify-content: center;
      }

      .top-form {
        flex-direction: column;
      }

      .top-form input[type="text"],
      .top-form button {
        width: 100%;
      }

      label {
        font-size: 1rem;
      }

      button {
        padding: 0.55rem 0.8rem;
      }

      input[type="checkbox"] {
        width: 1.1rem;
        height: 1.1rem;
      }

      .lists {
        gap: 1rem;
      }

      .item-row {
        padding: 0.55rem 0.45rem;
      }

      .drag-handle {
        width: 38px;
        height: 38px;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <div id="auth-bar" class="auth-bar">
      <span id="user-label"></span>
      <button id="login-btn" type="button">Log in</button>
      <button id="logout-btn" type="button" style="display:none;">Log out</button>
      <button id="test-api-btn" type="button" style="display:none;">Test API</button>
    </div>

    <h1>Shopping Planner</h1>
    <p class="subtitle">Built for fast on-the-go shopping — drag items with the handle or tap sections to keep things tidy.</p>

    <!-- Mode toggle -->
    <div id="mode-toggle" class="mode-toggle">
      <button type="button" class="mode-btn active" data-mode="shopping">Shopping</button>
      <button type="button" class="mode-btn" data-mode="menu">Menu</button>
    </div>

    <!-- List selector / manager -->
    <div class="list-switcher">
      <select id="list-select"></select>
      <button id="new-list-btn" type="button" class="primary">New list</button>
      <button id="rename-list-btn" type="button">Rename</button>
      <button id="delete-list-btn" type="button">Delete</button>
    </div>

    <!-- Add section (e.g. Monday, BBQ, Meal prep) -->
    <form id="add-section-form" class="top-form">
      <input
        id="section-input"
        type="text"
        placeholder="Add section (e.g. Monday, BBQ)…"
        autocomplete="off"
      />
      <button type="submit">Add section</button>
    </form>

    <div class="lists">
      <div class="drag-hint">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
          <path d="M9 3h6" /><path d="M9 12h6" /><path d="M9 21h6" />
        </svg>
        <span>Press and drag the handle for quick reordering on mobile.</span>
      </div>
      <!-- Sections with active items -->
      <div class="list-section">
        <div id="sections"></div>
        <div id="empty-all-active" class="empty">
          No items yet. Add a section to start.
        </div>
      </div>

      <!-- Completed items -->
      <div id="completed-section" class="list-section">
        <div class="completed-section-header">
          <h2>Completed</h2>
          <span id="completed-count" class="count"></span>
        </div>
        <ul id="completed-list"></ul>
        <div id="empty-completed" class="empty">
          Nothing completed yet
        </div>
      </div>
    </div>
  </div>

  <script>
    // DOM references
    const sectionsContainer = document.getElementById("sections");
    const addSectionFormEl = document.getElementById("add-section-form");
    const sectionInputEl = document.getElementById("section-input");

    const completedListEl = document.getElementById("completed-list");
    const completedCountEl = document.getElementById("completed-count");
    const emptyAllActiveEl = document.getElementById("empty-all-active");
    const emptyCompletedEl = document.getElementById("empty-completed");

    const listSelectEl = document.getElementById("list-select");
    const newListBtn = document.getElementById("new-list-btn");
    const renameListBtn = document.getElementById("rename-list-btn");
    const deleteListBtn = document.getElementById("delete-list-btn");

    const appEl = document.querySelector(".app");
    const modeToggleEl = document.getElementById("mode-toggle");
    let currentMode = "shopping";

    // Drag & drop state
    let sectionIdCounter = 1;
    let draggedItem = null;
    let dragTargetSection = null;
    let dragAfterElement = null;
    let activeTouchId = null;

    const dropIndicator = document.createElement("li");
    dropIndicator.className = "drop-indicator";

    // Persistence state
    const STORAGE_KEY = "shoppingPlannerLists_v1";
    let appState = null;
    let isRestoring = false;

    // ---------- Mode toggle ----------

    if (modeToggleEl) {
      modeToggleEl.addEventListener("click", (event) => {
        const btn = event.target.closest(".mode-btn");
        if (!btn) return;
        const newMode = btn.dataset.mode;
        if (!newMode || newMode === currentMode) return;

        // If leaving shopping mode, save state first
        if (currentMode === "shopping") {
          saveCurrentListState();
        }

        currentMode = newMode;

        document.querySelectorAll(".mode-btn").forEach((b) => {
          b.classList.toggle("active", b.dataset.mode === currentMode);
        });

        if (appEl) {
          appEl.classList.toggle("mode-menu", currentMode === "menu");
        }

        if (appState && appState.currentListId) {
          renderList(appState.currentListId);
        }
      });
    }

    // ---------- Persistence helpers ----------

    function saveAppStateToLocal() {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(appState));
      } catch (e) {
        console.error("Failed to save state:", e);
      }
    }

    function saveAppState() {
      // Always keep local copy
      saveAppStateToLocal();

      // If logged in, also push to server (fire-and-forget)
      if (window.currentUser) {
        // don’t await; we don’t need to block UI
        saveAppStateToServer();
      }
    }

    function serializeCurrentList() {
      const sectionsData = [];
      sectionsContainer.querySelectorAll(".section").forEach((sectionEl) => {
        const sectionName = sectionEl.querySelector("h2").textContent;
        const activeList = sectionEl.querySelector(".active-list");
        const items = [];
        if (activeList) {
          activeList.querySelectorAll(".item").forEach((li) => {
            const textEl = li.querySelector(".item-text");
            if (textEl) {
              items.push({ text: textEl.textContent });
            }
          });
        }
        sectionsData.push({ name: sectionName, items });
      });

      const completedData = [];
      completedListEl.querySelectorAll(".item").forEach((li) => {
        const textEl = li.querySelector(".item-text");
        if (!textEl) return;
        const sectionName = li.dataset.sectionName || "";
        completedData.push({
          text: textEl.textContent,
          sectionName,
        });
      });

      return {
        sections: sectionsData,
        completed: completedData,
      };
    }

    function saveCurrentListState() {
      if (!appState || !appState.currentListId) return;
      const list = appState.lists[appState.currentListId];
      if (!list) return;
      list.data = serializeCurrentList();
      saveAppState();
    }

    function refreshListSelect() {
      if (!appState) return;
      listSelectEl.innerHTML = "";
      const ids = Object.keys(appState.lists);
      ids.forEach((id) => {
        const list = appState.lists[id];
        const opt = document.createElement("option");
        opt.value = id;
        opt.textContent = list.name || "Untitled list";
        listSelectEl.appendChild(opt);
      });
      if (appState.currentListId && appState.lists[appState.currentListId]) {
        listSelectEl.value = appState.currentListId;
      }
    }

    // ---------- Rendering (shopping vs menu) ----------

    function renderShoppingList(listId) {
      const list = appState.lists[listId];
      isRestoring = true;

      sectionsContainer.innerHTML = "";
      completedListEl.innerHTML = "";

      let data = list.data;
      if (!data) {
        data = {
          sections: [{ name: "General", items: [] }],
          completed: [],
        };
        list.data = data;
      }

      // Build sections & active items
      data.sections.forEach((sectionData) => {
        addSection(sectionData.name);
        const sectionEls = sectionsContainer.querySelectorAll(".section");
        const sectionEl = sectionEls[sectionEls.length - 1];
        sectionData.items.forEach((item) => {
          addItemToSection(sectionEl, item.text);
        });
      });

      // Map section names -> current sectionIds
      const sectionMap = new Map();
      sectionsContainer.querySelectorAll(".section").forEach((sec) => {
        const name = sec.querySelector("h2").textContent;
        sectionMap.set(name, sec.dataset.sectionId);
      });

      // Build completed items
      data.completed.forEach((cItem) => {
        let sectionName = cItem.sectionName;
        let sectionId = sectionMap.get(sectionName);

        if (!sectionId) {
          // Fallback if section no longer exists: use first section or create one
          let targetSectionEl = sectionsContainer.querySelector(".section");
          if (!targetSectionEl) {
            addSection("General");
            const secEls = sectionsContainer.querySelectorAll(".section");
            targetSectionEl = secEls[secEls.length - 1];
          }
          sectionId = targetSectionEl.dataset.sectionId;
          sectionName = targetSectionEl.querySelector("h2").textContent;
          sectionMap.set(sectionName, sectionId);
        }

        const li = createItemElement(cItem.text, sectionName, sectionId);
        li.classList.add("completed-item");
        li.draggable = false;
        const checkbox = li.querySelector(".item-checkbox");
        if (checkbox) checkbox.checked = true;
        completedListEl.appendChild(li);
      });

      updateCountsAndEmptyStates();
      isRestoring = false;
    }

    // Menu view: no checkboxes, no Completed section, all items in their sections
    function renderMenuView(listId) {
      const list = appState.lists[listId];
      isRestoring = true;

      sectionsContainer.innerHTML = "";
      completedListEl.innerHTML = "";

      let data = list.data;
      if (!data) {
        data = {
          sections: [{ name: "General", items: [] }],
          completed: [],
        };
        list.data = data;
      }

      const sectionMap = new Map();

      // Create sections for all known section names
      data.sections.forEach((sectionData) => {
        const sectionEl = createSectionElement(sectionData.name);
        sectionsContainer.appendChild(sectionEl);
        sectionMap.set(sectionData.name, sectionEl);
      });

      function ensureSection(name) {
        let sectionEl = sectionMap.get(name);
        if (!sectionEl) {
          sectionEl = createSectionElement(name);
          sectionsContainer.appendChild(sectionEl);
          sectionMap.set(name, sectionEl);
        }
        return sectionEl;
      }

      // Add active items
      data.sections.forEach((sectionData) => {
        const sectionEl = ensureSection(sectionData.name);
        const activeList = sectionEl.querySelector(".active-list");
        sectionData.items.forEach((item) => {
          const li = document.createElement("li");
          li.className = "item";
          const textSpan = document.createElement("span");
          textSpan.className = "item-text";
          textSpan.textContent = item.text;
          li.appendChild(textSpan);
          activeList.appendChild(li);
        });
      });

      // Add completed items into their sections (no checkboxes, no strike-through)
      (data.completed || []).forEach((cItem) => {
        const sectionName = cItem.sectionName || "General";
        const sectionEl = ensureSection(sectionName);
        const activeList = sectionEl.querySelector(".active-list");
        const li = document.createElement("li");
        li.className = "item";
        const textSpan = document.createElement("span");
        textSpan.className = "item-text";
        textSpan.textContent = cItem.text;
        li.appendChild(textSpan);
        activeList.appendChild(li);
      });

      updateCountsAndEmptyStates();
      isRestoring = false;
    }

    function renderList(listId) {
      if (currentMode === "menu") {
        renderMenuView(listId);
      } else {
        renderShoppingList(listId);
      }
    }

    function initApp() {
      // Load state
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (raw) {
          appState = JSON.parse(raw);
        }
      } catch (e) {
        console.error("Failed to load state:", e);
      }

      if (!appState || !appState.lists) {
        appState = { currentListId: null, lists: {} };
      }

      const ids = Object.keys(appState.lists);

      if (ids.length === 0) {
        const defaultId = "list-" + Date.now().toString(36);
        appState.lists[defaultId] = {
          id: defaultId,
          name: "My list",
          data: {
            sections: [{ name: "General", items: [] }],
            completed: [],
          },
        };
        appState.currentListId = defaultId;
        saveAppState();
      } else if (!appState.currentListId || !appState.lists[appState.currentListId]) {
        appState.currentListId = ids[0];
      }

      refreshListSelect();
      renderList(appState.currentListId);

      // List switcher events
      listSelectEl.addEventListener("change", () => {
        const newId = listSelectEl.value;
        if (!newId || !appState.lists[newId]) return;
        // Save current list first (only meaningful in shopping mode)
        if (currentMode === "shopping") {
          saveCurrentListState();
        }
        appState.currentListId = newId;
        saveAppState();
        renderList(newId);
      });

      newListBtn.addEventListener("click", () => {
        const nameInput = prompt("Name for new list:", "New list");
        if (nameInput === null) return;
        const name = nameInput.trim() || "Untitled list";
        const id = "list-" + Date.now().toString(36) + "-" + Math.random().toString(36).slice(2, 8);
        appState.lists[id] = {
          id,
          name,
          data: {
            sections: [{ name: "General", items: [] }],
            completed: [],
          },
        };
        appState.currentListId = id;
        saveAppState();
        refreshListSelect();
        renderList(id);
      });

      renameListBtn.addEventListener("click", () => {
        if (!appState.currentListId) return;
        const current = appState.lists[appState.currentListId];
        if (!current) return;
        const newNameInput = prompt("Rename list:", current.name || "Untitled list");
        if (newNameInput === null) return;
        const newName = newNameInput.trim();
        if (!newName) return;
        current.name = newName;
        saveAppState();
        refreshListSelect();
      });

      deleteListBtn.addEventListener("click", () => {
        if (!appState.currentListId) return;
        const current = appState.lists[appState.currentListId];
        if (!current) return;
        if (!confirm(`Delete list "${current.name}"? This cannot be undone.`)) return;

        delete appState.lists[appState.currentListId];
        const idsAfter = Object.keys(appState.lists);

        if (idsAfter.length === 0) {
          const id = "list-" + Date.now().toString(36);
          appState.lists[id] = {
            id,
            name: "My list",
            data: {
              sections: [{ name: "General", items: [] }],
              completed: [],
            },
          };
          appState.currentListId = id;
        } else {
          appState.currentListId = idsAfter[0];
        }

        saveAppState();
        refreshListSelect();
        renderList(appState.currentListId);
      });
    }

    // Server data functions

    const REMOTE_STORAGE_ENABLED = true; // just in case you ever want to toggle it

    async function loadAppStateFromServer() {
      if (!REMOTE_STORAGE_ENABLED) return null;
      if (typeof getAuthToken !== "function") return null;

      const token = await getAuthToken();
      if (!token) return null;

      const res = await fetch("/.netlify/functions/get-state", {
        headers: {
          Authorization: `Bearer ${token}`,
        },
      });

      if (!res.ok) {
        console.error("Failed to load state from server", await res.text());
        return null;
      }

      return await res.json(); // either null or an appState object
    }

    async function saveAppStateToServer() {
      if (!REMOTE_STORAGE_ENABLED) return;
      if (typeof getAuthToken !== "function") return;

      console.log("Saving state to server…"); // debug line

      const token = await getAuthToken();
      if (!token) return;

      const res = await fetch("/.netlify/functions/save-state", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify(appState),
      });

      if (!res.ok) {
        console.error("Failed to save state to server", await res.text());
      }
    }

    async function syncStateWithServerAfterLogin() {
      const token = await getAuthToken();
      if (!token) return;

      const remote = await loadAppStateFromServer();
      console.log("Remote state from server:", remote);

      const hasValidRemote =
        remote &&
        typeof remote === "object" &&
        remote.lists &&
        Object.keys(remote.lists).length > 0;

      if (hasValidRemote) {
        // Use cloud state
        appState = remote;

        // Clear current DOM
        sectionsContainer.innerHTML = "";
        completedListEl.innerHTML = "";

        const ids = Object.keys(appState.lists);
        if (!appState.currentListId || !appState.lists[appState.currentListId]) {
          appState.currentListId = ids[0];
        }

        refreshListSelect();
        renderList(appState.currentListId);
      } else {
        // No usable server state yet → push current local state up
        await saveAppStateToServer();
      }
    }

    // ---------- UI helpers (counts, empty states) ----------

    function clearDropTargets() {
      const lists = sectionsContainer.querySelectorAll(".active-list");
      const dropAreas = sectionsContainer.querySelectorAll(".drop-area");
      lists.forEach((list) => list.classList.remove("drop-target"));
      dropAreas.forEach((area) => area.classList.remove("drop-target"));
    }

    function cleanupDragState() {
      if (draggedItem) {
        draggedItem.classList.remove("dragging");
      }

      if (dropIndicator.parentNode) {
        dropIndicator.parentNode.removeChild(dropIndicator);
      }

      clearDropTargets();
      dragTargetSection = null;
      dragAfterElement = null;
      draggedItem = null;
      activeTouchId = null;
    }

    function updateCountsAndEmptyStates() {
      const sections = sectionsContainer.querySelectorAll(".section");
      let totalActive = 0;

      sections.forEach((section) => {
        const activeList = section.querySelector(".active-list");
        const dropArea = section.querySelector(".drop-area");
        const countEl = section.querySelector("[data-role='active-count']");
        const activeCount = activeList ? activeList.querySelectorAll(".item").length : 0;
        totalActive += activeCount;

        if (countEl) {
          countEl.textContent = activeCount
            ? `${activeCount} item${activeCount !== 1 ? "s" : ""}`
            : "";
        }

        if (dropArea) {
          dropArea.classList.toggle("hidden", activeCount > 0);
        }
      });

      const completedCount = completedListEl.querySelectorAll(".item").length;
      completedCountEl.textContent = completedCount
        ? `${completedCount} item${completedCount !== 1 ? "s" : ""}`
        : "";

      emptyAllActiveEl.style.display = totalActive ? "none" : "block";
      emptyCompletedEl.style.display = completedCount ? "none" : "block";

      // Only persist when in shopping mode
      if (!isRestoring && appState && currentMode === "shopping") {
        saveCurrentListState();
      }
    }

    // ---------- Drag & drop helpers ----------

    function getDragAfterElement(container, y) {
      const draggableElements = [...container.querySelectorAll(".item:not(.dragging)")];

      let closest = { offset: Number.NEGATIVE_INFINITY, element: null };

      draggableElements.forEach((child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        if (offset < 0 && offset > closest.offset) {
          closest = { offset, element: child };
        }
      });

      return closest.element;
    }

    function finalizeDrop() {
      if (!draggedItem || !dragTargetSection) {
        cleanupDragState();
        return;
      }

      const activeList = dragTargetSection.querySelector(".active-list");
      if (!activeList) {
        cleanupDragState();
        return;
      }

      const sectionId = dragTargetSection.dataset.sectionId;
      const sectionName = dragTargetSection.querySelector("h2").textContent;

      if (dragAfterElement == null) {
        activeList.appendChild(draggedItem);
      } else {
        activeList.insertBefore(draggedItem, dragAfterElement);
      }

      // Update metadata and tag
      draggedItem.dataset.sectionId = sectionId;
      draggedItem.dataset.sectionName = sectionName;
      const tagSpan = draggedItem.querySelector(".section-tag");
      if (tagSpan) {
        tagSpan.textContent = `[${sectionName}]`;
      }

      updateCountsAndEmptyStates();
      cleanupDragState();
    }

    function startTouchDrag(event, itemEl) {
      const touch = event.changedTouches ? event.changedTouches[0] : null;
      if (!touch || !itemEl || draggedItem) return;
      event.preventDefault();

      activeTouchId = touch.identifier;
      draggedItem = itemEl;
      draggedItem.classList.add("dragging");
      dragTargetSection = itemEl.closest(".section");
      dragAfterElement = itemEl.nextElementSibling;

      const activeList = dragTargetSection?.querySelector(".active-list");
      if (activeList) {
        activeList.classList.add("drop-target");

        if (dropIndicator.parentNode && dropIndicator.parentNode !== activeList) {
          dropIndicator.parentNode.removeChild(dropIndicator);
        }

        if (dragAfterElement == null) {
          activeList.appendChild(dropIndicator);
        } else {
          activeList.insertBefore(dropIndicator, dragAfterElement);
        }
      }

      document.addEventListener("touchmove", handleTouchMove, { passive: false });
      document.addEventListener("touchend", endTouchDrag, { passive: false });
      document.addEventListener("touchcancel", endTouchDrag, { passive: false });
    }

    function handleTouchMove(event) {
      const touch = [...event.changedTouches].find((t) => t.identifier === activeTouchId) ||
        (activeTouchId == null ? event.touches[0] : null);
      if (!draggedItem || !touch) return;

      event.preventDefault();
      const el = document.elementFromPoint(touch.clientX, touch.clientY);
      const sectionEl = el ? el.closest(".section") : null;
      if (!sectionEl) return;

      dragTargetSection = sectionEl;
      const activeList = sectionEl.querySelector(".active-list");
      if (!activeList) return;

      clearDropTargets();
      activeList.classList.add("drop-target");

      const afterElement = getDragAfterElement(activeList, touch.clientY);
      dragAfterElement = afterElement;

      if (dropIndicator.parentNode && dropIndicator.parentNode !== activeList) {
        dropIndicator.parentNode.removeChild(dropIndicator);
      }

      if (afterElement == null) {
        activeList.appendChild(dropIndicator);
      } else {
        activeList.insertBefore(dropIndicator, afterElement);
      }
    }

    function endTouchDrag(event) {
      if (activeTouchId != null) {
        const touch = [...event.changedTouches].find((t) => t.identifier === activeTouchId);
        if (!touch) return;
      }

      if (draggedItem) {
        finalizeDrop();
      } else {
        cleanupDragState();
      }

      document.removeEventListener("touchmove", handleTouchMove);
      document.removeEventListener("touchend", endTouchDrag);
      document.removeEventListener("touchcancel", endTouchDrag);
    }

    function setupDropZoneForSection(sectionEl) {
      const activeList = sectionEl.querySelector(".active-list");
      const dropArea = sectionEl.querySelector(".drop-area");

      if (activeList) {
        activeList.addEventListener("dragover", (event) => {
          if (!draggedItem) return;
          event.preventDefault();

          clearDropTargets();
          activeList.classList.add("drop-target");

          dragTargetSection = sectionEl;
          const afterElement = getDragAfterElement(activeList, event.clientY);
          dragAfterElement = afterElement;

          if (dropIndicator.parentNode && dropIndicator.parentNode !== activeList) {
            dropIndicator.parentNode.removeChild(dropIndicator);
          }

          if (afterElement == null) {
            activeList.appendChild(dropIndicator);
          } else {
            activeList.insertBefore(dropIndicator, afterElement);
          }
        });

        activeList.addEventListener("dragleave", (event) => {
          if (!draggedItem) return;
          const related = event.relatedTarget;
          if (!related || !activeList.contains(related)) {
            activeList.classList.remove("drop-target");
          }
        });

        activeList.addEventListener("drop", (event) => {
          if (!draggedItem) return;
          event.preventDefault();
          finalizeDrop();
        });
      }

      if (dropArea) {
        dropArea.addEventListener("dragover", (event) => {
          if (!draggedItem) return;
          event.preventDefault();

          clearDropTargets();
          dropArea.classList.add("drop-target");

          dragTargetSection = sectionEl;
          dragAfterElement = null;

          const al = sectionEl.querySelector(".active-list");
          if (!al) return;

          if (dropIndicator.parentNode && dropIndicator.parentNode !== al) {
            dropIndicator.parentNode.removeChild(dropIndicator);
          }
          al.appendChild(dropIndicator);
        });

        dropArea.addEventListener("dragleave", (event) => {
          if (!draggedItem) return;
          const related = event.relatedTarget;
          if (!related || !dropArea.contains(related)) {
            dropArea.classList.remove("drop-target");
          }
        });

        dropArea.addEventListener("drop", (event) => {
          if (!draggedItem) return;
          event.preventDefault();
          finalizeDrop();
        });
      }
    }

    // ---------- Section & item creation ----------

    function createSectionElement(name) {
      const id = String(sectionIdCounter++);
      const section = document.createElement("section");
      section.className = "section";
      section.dataset.sectionId = id;

      section.innerHTML = `
        <div class="section-header">
          <h2>${name}</h2>
          <span class="count" data-role="active-count"></span>
        </div>
        <form class="item-form">
          <input
            type="text"
            class="item-input"
            placeholder="Add item to ${name}…"
            autocomplete="off"
          />
          <button type="submit">Add</button>
        </form>
        <div class="drop-area" data-role="drop-area">
          Drop items here or drag with the handle
        </div>
        <ul class="active-list"></ul>
      `;

      setupDropZoneForSection(section);
      return section;
    }

    function addSection(name) {
      if (!name) return;
      const section = createSectionElement(name);
      sectionsContainer.appendChild(section);
      updateCountsAndEmptyStates();

      const input = section.querySelector(".item-input");
      if (input) input.focus();
    }

    function createItemElement(name, sectionName, sectionId) {
      const li = document.createElement("li");
      li.className = "item";
      li.dataset.sectionId = sectionId || "";
      li.dataset.sectionName = sectionName || "";

      li.draggable = true;
      li.addEventListener("dragstart", (event) => {
        draggedItem = li;
        li.classList.add("dragging");
        if (event.dataTransfer) {
          event.dataTransfer.effectAllowed = "move";
          event.dataTransfer.setData("text/plain", "");
        }
      });

      li.addEventListener("dragend", () => {
        cleanupDragState();
      });

      const label = document.createElement("label");

      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.className = "item-checkbox";

      const textSpan = document.createElement("span");
      textSpan.className = "item-text";
      textSpan.textContent = name;

      const tagSpan = document.createElement("span");
      tagSpan.className = "section-tag";
      tagSpan.textContent = `[${sectionName}]`;

      label.appendChild(checkbox);
      label.appendChild(textSpan);
      label.appendChild(tagSpan);

      const row = document.createElement("div");
      row.className = "item-row";

      const dragHandle = document.createElement("button");
      dragHandle.type = "button";
      dragHandle.className = "drag-handle";
      dragHandle.setAttribute("aria-label", "Drag to reorder");
      dragHandle.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
          <g fill="currentColor">
            <circle cx="9" cy="6.5" r="1.4" />
            <circle cx="9" cy="12" r="1.4" />
            <circle cx="9" cy="17.5" r="1.4" />
            <circle cx="15" cy="6.5" r="1.4" />
            <circle cx="15" cy="12" r="1.4" />
            <circle cx="15" cy="17.5" r="1.4" />
          </g>
        </svg>
      `;

      dragHandle.addEventListener("touchstart", (event) => {
        startTouchDrag(event, li);
      }, { passive: false });

      row.appendChild(dragHandle);
      row.appendChild(label);
      li.appendChild(row);

      return li;
    }

    function addItemToSection(sectionEl, itemName) {
      if (!itemName) return;
      const activeList = sectionEl.querySelector(".active-list");
      const sectionName = sectionEl.querySelector("h2").textContent;
      const sectionId = sectionEl.dataset.sectionId;

      const li = createItemElement(itemName, sectionName, sectionId);
      activeList.appendChild(li);

      updateCountsAndEmptyStates();
    }

    // ---------- Event wiring for sections/items ----------

    // Add section form (top)
    addSectionFormEl.addEventListener("submit", (event) => {
      event.preventDefault();
      const value = sectionInputEl.value.trim();
      if (!value) return;
      addSection(value);
      sectionInputEl.value = "";
    });

    // Adding items to specific sections (event delegation)
    sectionsContainer.addEventListener("submit", (event) => {
      const form = event.target.closest(".item-form");
      if (!form) return;

      event.preventDefault();
      const input = form.querySelector(".item-input");
      const value = input.value.trim();
      if (!value) return;

      const sectionEl = form.closest(".section");
      if (!sectionEl) return;

      addItemToSection(sectionEl, value);
      input.value = "";
      input.focus();
    });

    // Move from section active list -> Completed when checked
    sectionsContainer.addEventListener("change", (event) => {
      if (!event.target.matches(".item-checkbox")) return;
      if (!event.target.checked) return;

      const li = event.target.closest("li");
      if (!li) return;

      li.classList.add("completed-item");
      li.draggable = false;
      completedListEl.appendChild(li);

      updateCountsAndEmptyStates();
    });

    // Move from Completed -> back to original section when UNchecked
    completedListEl.addEventListener("change", (event) => {
      if (!event.target.matches(".item-checkbox")) return;

      const li = event.target.closest("li");
      if (!li) return;

      if (!event.target.checked) {
        const sectionId = li.dataset.sectionId;
        let sectionEl = sectionsContainer.querySelector(
          `.section[data-section-id="${sectionId}"]`
        );

        if (!sectionEl) {
          sectionEl = sectionsContainer.querySelector(".section");
        }

        if (sectionEl) {
          li.classList.remove("completed-item");
          const activeList = sectionEl.querySelector(".active-list");
          activeList.appendChild(li);
          li.draggable = true;
          updateCountsAndEmptyStates();
        }
      }
    });

    // ---------- Kick things off ----------
    initApp();
  </script>

  <script>
    // === Auth0 + API wiring ===
  
    // 1. Fill these in from your Auth0 dashboard:
    const AUTH0_DOMAIN = "dev-ep1kkf5cbz6dcdgn.us.auth0.com";          // e.g. "dev-abc123.eu.auth0.com"
    const AUTH0_CLIENT_ID = "siGMrsujybw4rQaZEgZssLXYEVoPi7AD";    // from your SPA application's settings
    const AUTH0_AUDIENCE = "https://shopping-planner-api"; // the API Identifier you created
  
    let auth0Client = null;
    let currentUser = null;
  
    function updateAuthBar() {
      const userLabel = document.getElementById("user-label");
      const loginBtn = document.getElementById("login-btn");
      const logoutBtn = document.getElementById("logout-btn");
      const testApiBtn = document.getElementById("test-api-btn");
  
      if (!userLabel || !loginBtn || !logoutBtn || !testApiBtn) return;
  
      if (currentUser) {
        userLabel.textContent = `Logged in as ${currentUser.email || "User"}`;
        loginBtn.style.display = "none";
        logoutBtn.style.display = "inline-block";
        testApiBtn.style.display = "inline-block";
      } else {
        userLabel.textContent = "";
        loginBtn.style.display = "inline-block";
        logoutBtn.style.display = "none";
        testApiBtn.style.display = "none";
      }
    }
  
    async function initAuth0() {
      auth0Client = await auth0.createAuth0Client({
        domain: AUTH0_DOMAIN,
        clientId: AUTH0_CLIENT_ID,
        authorizationParams: {
          redirect_uri: window.location.origin,
          audience: AUTH0_AUDIENCE
        }
      });
  
      // Handle Auth0 redirect back (after login)
      if (window.location.search.includes("code=") &&
          window.location.search.includes("state=")) {
        try {
          await auth0Client.handleRedirectCallback();
        } catch (e) {
          console.error("Error handling redirect callback:", e);
        }
        // Clean up the URL
        window.history.replaceState({}, document.title, window.location.pathname);
      }
  
      const isAuthenticated = await auth0Client.isAuthenticated();
      if (isAuthenticated) {
        currentUser = await auth0Client.getUser();
        // make it visible to the first script
        window.currentUser = currentUser;
        // sync appState with Neon now that we know who this is
        if (typeof syncStateWithServerAfterLogin === "function") {
          syncStateWithServerAfterLogin();
        }
      } else {
        currentUser = null;
        window.currentUser = null;
      }
  
      updateAuthBar();
    }
  
    async function getAuthToken() {
      if (!auth0Client) return null;
      const isAuthenticated = await auth0Client.isAuthenticated();
      if (!isAuthenticated) return null;
  
      try {
        const token = await auth0Client.getTokenSilently({
          authorizationParams: {
            audience: AUTH0_AUDIENCE
          }
        });
        return token;
      } catch (e) {
        console.error("Error getting token silently:", e);
        return null;
      }
    }
  
    async function testApiCall() {
      const token = await getAuthToken();
      if (!token) {
        console.warn("No token available – are you logged in?");
        alert("No token available – try logging in first.");
        return;
      }
  
      try {
        const res = await fetch("/.netlify/functions/get-state", {
          headers: {
            Authorization: `Bearer ${token}`
          }
        });
  
        const text = await res.text();
        console.log("get-state response:", res.status, text);
  
        alert("Check the browser console for get-state response.");
      } catch (e) {
        console.error("Error calling get-state:", e);
        alert("Error calling API – see console.");
      }
    }
  
    function setupAuthUI() {
      const loginBtn = document.getElementById("login-btn");
      const logoutBtn = document.getElementById("logout-btn");
      const testApiBtn = document.getElementById("test-api-btn");
  
      if (!loginBtn || !logoutBtn || !testApiBtn) return;
  
      loginBtn.addEventListener("click", async () => {
        // redirect to Auth0's hosted login page
        await auth0Client.loginWithRedirect();
      });
  
      logoutBtn.addEventListener("click", async () => {
        await auth0Client.logout({
          logoutParams: {
            returnTo: window.location.origin
          }
        });
      });
  
      testApiBtn.addEventListener("click", testApiCall);
    }
  
    // Initialise Auth0 + wire buttons once the page is loaded
    window.addEventListener("load", async () => {
      try {
        await initAuth0();
        setupAuthUI();
      } catch (e) {
        console.error("Error initializing Auth0:", e);
      }
    });
  </script>
  
</body>
</html>
